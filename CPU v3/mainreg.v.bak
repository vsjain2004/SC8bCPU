module mainreg(IN, MRWE, WA0, WA1, RA0, RA1, RA2, RA3, RA4, CLK, RESET, SWAPR, OUTA, OUTB, OUTC, OA, OB, OC, OIX);
	input MRWE, WA0, WA1, RA0, RA1, RA2, RA3, RA4, CLK, RESET, SWAPR;
	input [7:0] IN;
	output [7:0] OUTA, OUTB, OUTC, OA, OB, OC, OIX;
	
	wire [7:0] OZ, OO;
	
	/*
		EN = SWAPR or MRWE;
		S1 = SWAPR ? RA1 : WA1;
		S0 = SWAPR ? RA0 : WA0;
	*/
	Decoder2to4 decoder(.S1(WA1), .S0(WA0), .EN(MRWE), .Y0(Y0), .Y1(Y1), .Y2(Y2), .Y3(Y3)); //RY0, 1, 2
	
	// Decoder2to4 decoder(.S1(RA3), .S0(RA2), .EN(SWAPR), .Y0(SY0), .Y1(SY1), .Y2(SY2), .Y3());
	
	// Reg A, B, C load en = decoder1 or decoder2 appropriate output.
	/*
		Ys = SYs | RYs for 0, 1, 2.
	*/
	
	/* Reg In logic: 
	for A, B, C:
		if swapr
			if RA1,0 == Reg code
				OutB
			else if RA3,2 == Reg code
				OutA
		else
			IN
			
	for IX:
		if swapr and RA1,0 == 11:
			OutB
		else
			IN
	*/
	
	reg_8_bit A(.IN(IN), .LOAD(Y0), .CLK(CLK), .OUT(OA), .PRESET_N(1), .CLEAR_N(RESET));
	reg_8_bit B(.IN(IN), .LOAD(Y1), .CLK(CLK), .OUT(OB), .PRESET_N(1), .CLEAR_N(RESET));
	reg_8_bit C(.IN(IN), .LOAD(Y2), .CLK(CLK), .OUT(OC), .PRESET_N(1), .CLEAR_N(RESET));
	reg_8_bit IX(.IN(IN), .LOAD(Y3), .CLK(CLK), .OUT(OIX), .PRESET_N(1), .CLEAR_N(RESET));
	Zeros Z(.Z(OZ));
	Ones O(.O(OO));
	
	busmux_4_to_1 opa(.In1(OA), .In2(OB), .In3(OC), .In4(OIX), .s1(RA1), .s0(RA0), .Out(OUTA));
	busmux_4_to_1 opb(.In1(OA), .In2(OB), .In3(OC), .In4(OIX), .s1(RA3), .s0(RA2), .Out(OUTB));
	busmux_4_to_1 opc(.In1(OZ), .In2(OO), .In3(OZ), .In4(OO), .s1(1), .s0(RA4), .Out(OUTC));
endmodule